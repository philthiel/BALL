//_new_file_header


#ifndef BALL_CORE_STRUCTURE_STRUCTUREMAPPER_H
#define BALL_CORE_STRUCTURE_STRUCTUREMAPPER_H

#include <BALL/core/concept/processor.h>
#include <BALL/core/datatype/string.h>
#include <BALL/core/kernel/atom.h>
#include <BALL/core/kernel/protein.h>
#include <BALL/core/maths/matrix44.h>
#include <BALL/core/structure/atomBijection.h>
#include <BALL/core/structure/geometricTransformations.h>

#include <list>
#include <map>
#include <vector>


namespace BALL 
{

	/**	Structure mapping class.
	\ingroup StructureMapping
	*/
	class BALL_EXPORT StructureMapper
		:	public TransformationProcessor
	{
		public:

		/**	@name	Constructors and Destructors
		*/
		//@{
		
		/**	Default constructor
		*/
		StructureMapper();

		/**	Constructor
		*/
		StructureMapper(AtomContainer& A, AtomContainer& B);

		/**	Destructor
		*/
		virtual ~StructureMapper();

		//@}

		/**	Assign the two objects to be mapped
		*/
		void set(AtomContainer& A, AtomContainer& B);

		/**	Calculate the root mean squared deviation
		*/
		double calculateRMSD();

		/**	Calculate the root mean squared deviation given a AtomBijection
		*/
		double calculateRMSD(const AtomBijection& new_bijection);

		/**	Calculate the transformation to map the first of two isomorphous 
				AtomContainer objects onto the second
		*/
		bool calculateTransformation();

		/**	Calculate a reasonable bijection for the mapping of A and B
		*/
		void calculateDefaultBijection(bool limit_to_selection = false);

		/**	Return the current bijection
		*/
		const AtomBijection& getBijection() const { return bijection_; }

		/**	Calculates a bijection to map two arrays of fragments onto each other.
		*/
		AtomBijection calculateFragmentBijection
			(const std::vector<Fragment*>& A, const std::vector<Fragment*>& B);

		/**	Maps two fragments onto each other
		*/
		bool mapFragments
			(const std::vector<Fragment*>& A, const std::vector<Fragment*>& B,
			 Matrix4x4* transformation, double upper_bound = 8.0, double lower_bound = 2.5);

		/**	Map three points onto each other.
				Computes a transformation that maps

					- the point <tt>w1</tt> onto the point <tt>v1</tt>,
					- the point <tt>w2</tt> onto the ray that starts in <tt>v1</tt> and goes through <tt>v2</tt>,
					- the point <tt>w3</tt> into the plane generated by <tt>v1</tt>, <tt>v2</tt>, and <tt> v3</tt>.
				
		*/
		static Matrix4x4 matchPoints
			(const Vector3& w1,	const Vector3& w2, const Vector3& w3,	
			 const Vector3& v1,	const Vector3& v2, const Vector3& v3);

		/**	
		*/
		static Matrix4x4 matchBackboneAtoms(const Residue& r1, const Residue& r2);

		/**	
		*/
		Size mapResiduesByBackbone(const std::list<Residue*>& l1, const std::list<Residue*>& l2);
	 
		/**
		*/
		std::vector<std::vector<Fragment*> >& searchPattern
			(std::vector<Fragment*>& pattern, AtomContainer& composite,
			 double max_rmsd = 4.0,	   double max_center_tolerance = 2.0,
			 double upper_bound = 8.0, double lower_bound = 4.0);

		/**	Map two proteins onto each other.
		*/
		Matrix4x4 mapProteins
			(Protein& P1, Protein& P2, 
			 std::map<String, Size>&	type_map,
			 Size&							no_matched_ca,
			 double&						rmsd,
			 double							upper_bound = 8.0,
			 double							lower_bound = 4.0,
			 double							tolerance = 0.6);

		protected:
		// Count the fragments in an AtomContainer -- this is not implemented
		// in AtomContainer!
		Size countFragments_(const AtomContainer& ac) const;

		/*_	The first of two composites - the "original" 
		*/
		AtomContainer*	A_;

		/*_	The second composites - the "copy" to be mapped 
		*/
		AtomContainer*	B_;
		
		/*_	The current atom bijection.
				Required for the caclulation of the RMSD.
		*/
		AtomBijection bijection_;
		
		/*_	The rmsd of the last mapping executed 
		*/
		double	rmsd_;
	};

} // namespace BALL

#endif // BALL_CORE_STRUCTURE_STRUCTUREMAPPER_H

